
from flask import Flask, render_template, request,redirect, jsonify, send_file
import tensorflow as tf
from tensorflow.keras.models import load_model
import pyrebase
import PyPDF2
import os
import numpy as np
from PIL import Image, ImageOps
import io
from fpdf import FPDF

app = Flask(__name__)


# Firebase Configuration
firebaseConfig = {
    "apiKey": "AIzaSyBUc09vVr13lufna3PcRKIvkScJMmL84F8",
    "authDomain": "diabetic-retinopathy-d9ad0.firebaseapp.com",
    "databaseURL": "https://diabetic-retinopathy-d9ad0-default-rtdb.firebaseio.com",
    "projectId": "diabetic-retinopathy-d9ad0",
    "storageBucket": "diabetic-retinopathy-d9ad0.appspot.com",
    "messagingSenderId": "784479554899",
    "appId": "1:784479554899:web:741bb70f664687c789e5a6",
    "measurementId": "G-T9E5GHPJ65"
}

firebase = pyrebase.initialize_app(firebaseConfig)
auth = firebase.auth()
db = firebase.database()
storage = firebase.storage()
# Define the model path

MODEL_PATH = "C:\\Users\\rithi\\Downloads\\Diabetic_Retinopathy_Project\\Diabetic_Retinopathy_Project\\dr_weights.h5"

# Load the model
try:
    if os.path.exists(MODEL_PATH):
        print(f"‚úÖ Loading model from: {MODEL_PATH}")
        model = load_model(MODEL_PATH)
        print("‚úÖ Model Loaded Successfully!")
    else:
        print(f"‚ùå ERROR: Model file not found at {MODEL_PATH}")
        model = None
except Exception as e:
    print(f"üö® Model Loading Error: {e}")
    model = None


# üîπ Function for Image Prediction
def import_and_predict(image_data):
    size = (224, 224)
    image = ImageOps.fit(image_data, size, Image.Resampling.LANCZOS)
    img_array = np.asarray(image) / 255.0  # Normalize
    img_array = img_array[..., :3] if img_array.shape[-1] == 4 else img_array  # Remove Alpha if exists
    img_reshape = np.expand_dims(img_array, axis=0)  # Add batch dimension

    prediction = model.predict(img_reshape)
    return prediction

# üîπ Home Route
@app.route("/patient_main")
def patient_main():
    return render_template("patient_main.html")

# üîπ Upload and Predict Route
@app.route("/predict", methods=["POST"])
def predict():
    if "file" not in request.files or "name" not in request.form:
        return jsonify({"error": "No file or name provided"}), 400

    file = request.files["file"]
    name = request.form["name"]
    image = Image.open(file)

    prediction = import_and_predict(image)
    class_names = ["NO DR", "Mild DR", "Moderate DR", "Severe DR", "Proliferative DR"]
    dr = class_names[np.argmax(prediction)]
    confidence_score = np.max(prediction) * 100  # Convert to percentage

    # Store in Firebase
    db.child("Patients").child(name).update({"diabetic_retinopathy": dr, "confidence": confidence_score})

    return jsonify({"name": name, "prediction": dr, "confidence": confidence_score})

# üîπ Generate and Download Report Route
@app.route("/download_report", methods=["GET"])
def download_report():
    name = request.args.get("name", "Unknown")
    diagnosis = request.args.get("diagnosis", "Not Available")
    confidence = request.args.get("confidence", "0")

    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt="Diabetic Retinopathy Report", ln=True, align="C")
    pdf.cell(200, 10, txt=f"Patient Name: {name}", ln=True, align="L")
    pdf.cell(200, 10, txt=f"Diagnosis: {diagnosis}", ln=True, align="L")
    pdf.cell(200, 10, txt=f"Confidence Score: {confidence}%", ln=True, align="L")
    pdf.cell(200, 10, txt="Generated by EyeDR AI System", ln=True, align="L")

    pdf_output = io.BytesIO()
    pdf.output(pdf_output, 'F')
    pdf_output.seek(0)

    return send_file(pdf_output, as_attachment=True, download_name=f"{name}_Diagnosis_Report.pdf")


# Function to Save Summary
def save_summary(original_text, summary):
    try:
        db.child("summaries").push({"original_text": original_text, "summary": summary})
    except Exception as e:
        print(f"Error saving summary: {e}")

# Function to Get All Summaries
def get_summaries():
    try:
        summaries = db.child("summaries").get()
        return summaries.val().values() if summaries.val() else []
    except Exception as e:
        print(f"Error fetching summaries: {e}")
        return []

# üü¢ Route: Form for Summarization
@app.route('/summarise')
def summarise_form():
    return render_template("summarise.html")

# üü¢ Route: Summarize Text & Store in Firebase
@app.route('/summarise', methods=['POST'])
def summarise_text():
    if request.method == 'POST':
        text = request.form.get("text")  # Get input text
        summary = " ".join(text.split()[:10]) + "..."  # Simple summarization logic
        save_summary(text, summary)  # Save to Firebase
        return render_template("summarise.html", name=summary)

UPLOAD_FOLDER = os.path.join(os.getcwd(), "uploads")  # Create an 'uploads' folder in the project directory
os.makedirs(UPLOAD_FOLDER, exist_ok=True)  # Ensure the folder exists

app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER  # Set the config variable

@app.route("/summarize", methods=["POST"])
def summarizePDF():
    if "file" not in request.files:
        return "No file part", 400
    
    f = request.files["file"]
    
    if f.filename == "":
        return "No selected file", 400

    # ‚úÖ Use the correctly defined upload folder
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], f.filename)
    f.save(file_path)

    return f"File successfully uploaded to {file_path}"

def upload_pdf(file_path, user_id):
    storage_path = f"pdf_reports/{user_id}/{file_path.split('/')[-1]}"  # Organize by user
    storage.child(storage_path).put(file_path)
    
    # Get download URL
    file_url = storage.child(storage_path).get_url(None)
    
    # Store metadata in Firebase Realtime Database
    data = {
        "user_id": user_id,
        "file_name": file_path.split('/')[-1],
        "file_url": file_url
    }
    db.child("pdf_reports").push(data)

    print(f"File uploaded successfully! URL: {file_url}")
    return file_url

@app.route('/summarisePDF', methods=['POST'])
def summrisePDF():
    if request.method == 'POST':
        f = request.files['file']

        # Step 2: Check if a file was uploaded
        if f.filename == '':
            return "No file uploaded. Please select a file and try again."

        # Step 3: Save file to "uploads" folder
        file_path = os.path.join(app.config["UPLOAD_FOLDER"], f.filename)
        f.save(file_path)

        # Step 4: Check if file exists before opening
        if not os.path.exists(file_path):
            return "Error: File not found after upload."

        # Step 5: Open and process the PDF file
        with open(file_path, 'rb') as pdfFileObj:
            pdfReader = PyPDF2.PdfReader(pdfFileObj)
            pageObj = pdfReader.pages[0]  # Correct way to access the first page
            txt = pageObj.extract_text()  

        return render_template("summarise.html", name=txt)  # Display extracted text
    

@app.route('/summarise-section')
def view_summarise_section():
    return render_template('summarise-section.html')  # Ensure the HTML file exists in the templates folder

@app.route('/summaries')
def view_summaries():
    summaries = get_summaries()
    return render_template("summaries.html", summaries=summaries)

@app.route('/')
def index():
    return render_template('index.html')
 # Ensure 'index.html' exists in the 'templates/' folder

@app.route('/login')
def login():
    return render_template("login.html")

@app.route('/signup')
def signup():
    return render_template("signup.html")

@app.route('/patient')
def patient_dashboard():
    return render_template('patient.html')

@app.route('/doctor')
def doctor():
    return render_template('doctor.html')

@app.route("/doctor_dashboard")
def doctor_dashboard():
    return render_template("doctor_dashboard.html")

@app.route('/posebot')
def posebot():
    return render_template('posebot.html')

@app.route('/posebots')  # This route must match the link in patient.html
def posebots():
    return render_template("posebots.html")

@app.route('/app1')
def app1():
    return render_template('app1.py')


@app.route("/save-session", methods=["POST"])
def save_session():
    from flask import request, jsonify
    data = request.json
    db.collection("sessions").add({
        "user": data.get("user", "unknown"),
        "duration": data.get("duration", "00:00:00"),
        "timestamp": firestore.SERVER_TIMESTAMP
    })
    return jsonify({"status": "success", "message": "Session saved!"}), 200


@app.route('/palming',methods=['POST','GET'])
def palming():
    url="https://teachablemachine.withgoogle.com/models/vKItIykyq/"
    return render_template('posebot.html', url=url)

@app.route('/trataka',methods=['POST','GET'])
def trataka():
    url="https://teachablemachine.withgoogle.com/models/YBbEKwztQ/"
    return render_template('posebot.html', url=url)

@app.route('/bhramamudra',methods=['POST','GET'])
def bhramamudra():
    url="https://teachablemachine.withgoogle.com/models/znvpEncRJ/"
    return render_template('posebot.html', url=url)

@app.route('/pranayama',methods=['POST','GET'])
def pranayama():
    url="https://teachablemachine.withgoogle.com/models/ZW47sepej/"
    return render_template('posebot.html', url=url)

@app.route('/parvatasana',methods=['POST','GET'])
def parvatasana():
    url="https://teachablemachine.withgoogle.com/models/JnfkxNVh3/"
    return render_template('posebot.html', url=url)
@app.route('/login/patient', methods=['POST', 'GET'])
def login_patient():
    if request.method == 'POST':
        int_features = [x for x in request.form.values()]
        if len(int_features) < 3:
            return "Error: Please fill in all fields."

        name, email, password = int_features[:3]
        users = db.child("Patient").child(name).get()

        if users.each() is not None:
            for user in users.each():
                if user.val() == email:
                    try:
                        auth.sign_in_with_email_and_password(email, password)
                        print("Patient Successfully Signed In")
                        return render_template('patient.html', name=name)
                    except Exception as e:
                        print(f"Login Error: {e}")
                        return "Invalid Email or Password."
    
    return render_template('login.html')

@app.route('/login/doctor',methods=['POST','GET'])
def login_doctor():
    flag=0
    flag2=0
    int_features=[x for x in request.form.values()]
    print(int_features)
    name=int_features[0]
    email=int_features[1]
    password=int_features[2]
    users = db.child("Doctors").child(name).get()
    if(users.each()!=None):
        flag2=1
        for user in users.each():
            if(user.val()==email):
                print('found')
                flag=1
    if(flag==1 and flag2==1):
        try:
            auth.sign_in_with_email_and_password(email, password)
            print("Doctor Succesfully SignedIn")
            return render_template('doctor.html', name=name) 
        except:
            print("Invalid User Or Password")
    return render_template('login.html')


@app.route('/signup/doctor',methods=['POST','GET'])
def signup_doctor():
    int_features=[x for x in request.form.values()]
    print(int_features)
    name=int_features[0]
    email=int_features[1]
    password=int_features[2]
    confirmpasswd=int_features[3]
    designation=int_features[4]
    hospital=int_features[5]
    if(password==confirmpasswd):
        try:
            auth.create_user_with_email_and_password(email,password)
            print("Doctor Created")
            data={"name":name, "email": email, "designation":designation, "hospital":hospital }
            print(email)
            db.child("Doctors").child(name).set(data)
            return render_template('doctor.html', name=name)
        except:
            print("Email already Exists")
    return render_template('signup.html')

@app.route('/signup/patient', methods=['POST', 'GET'])
def signup_patient():
    if request.method == 'POST':
        int_features = [x for x in request.form.values()]
        if len(int_features) < 7:
            return "Error: Please fill in all fields."

        name, email, password, confirmpassword, height, weight, age = int_features

        if password != confirmpassword:
            return "Error: Passwords do not match."

        try:
            auth.create_user_with_email_and_password(email, password)
            print("Patient Created Successfully")
            data = {"name": name, "email": email, "age": age, "height": height, "weight": weight}
            db.child("Patient").child(name).set(data)
            return render_template('patient.html', name=name)
        except Exception as e:
            print(f"Signup Error: {e}")
            return "Email already exists or Invalid credentials."

    return render_template('signup.html')


@app.route('/view_patients', methods=['POST','GET'])
def view_patients():
    patients=[]
    users = db.child("Patient").get()
    for user in users.each():
        patients.append(user.val())
    print(patients)
    return render_template('patientlist.html', patients=patients)

@app.route('/report', methods=['POST','GET'])
def report():
    patients=[]
    users = db.child("Patient").get()
    for user in users.each():
        patients.append(user.val())
    int_features=[x for x in request.form.values()]
    print(int_features)
    name=int_features[0]
    report=int_features[1]
    db.child("Patient").child(name).update({"report":report})
    return redirect('/view_patients')

@app.route('/patientreport', methods=['POST','GET'])
def patientreport():
    int_features=[x for x in request.form.values()]
    print(int_features)
    name=int_features[0]
    details = db.child("Patient").child(name).get()
    patient=details.val()
    return render_template('report.html', name=name, x=patient)


if __name__ == '__main__':
    app.run(debug=True)


